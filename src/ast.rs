use crate::lexer::Lexer;
use crate::lexer::Token;

#[derive(Debug, PartialEq)]
pub enum Operator {
    Plus,
}

#[derive(Debug, PartialEq)]
pub enum ASTNode {
    Program(Vec<ASTNode>),

    FunctionDeclaration(String, Vec<String>, Vec<ASTNode>),
    FunctionCall(String, Vec<ASTNode>),

    Statement(Box<ASTNode>),
    LetDeclaration(String, Box<ASTNode>),
    Print(Box<ASTNode>),
    BinaryOp(Box<ASTNode>, Operator, Box<ASTNode>),
    Identifier(String),
    IntegerLiteral(i32),
}

/// Parser for the simple Pyro programming language.
///
/// The `Parser` struct provides a basic recursive descent parser
/// that can parse a stream of tokens generated by the `Lexer` into
/// an abstract syntax tree (AST) representing the program.
pub struct Parser<'a> {
    lexer: Lexer<'a>,
    current_token: Option<Token>,
    next_token: Option<Token>,
}

impl<'a> Parser<'a> {
    pub fn new(lexer: Lexer<'a>) -> Parser<'a> {
        let mut parser = Parser {
            lexer,
            current_token: None,
            next_token: None,
        };

        let init_parser = |parser: &mut Parser| -> Result<(), String> {
            parser.advance()?;
            parser.advance()?;
            Ok(())
        };

        if let Err(_err) = init_parser(&mut parser) {
            panic!("Error while initializing parser");
        }

        parser
    }

    /// Advance the internal lexer.
    fn advance(&mut self) -> Result<(), String> {
        self.current_token = self.next_token.take();
        self.next_token = self.lexer.next_token()?;
        Ok(())
    }

    /// Expect a specific token, pop and return it.
    fn expect(&mut self, expected: Token) -> Result<(), String> {
        match self.current_token.clone() {
            Some(token) if token == expected => self.advance(),
            Some(token) => Err(format!(
                "Expected token {:?} but received {:?}",
                expected, token
            )),
            None => Err(format!("Expected token {:?} but got no token", expected)),
        }
    }

    /// Expect an identifier Token and return the identifier
    fn expect_identifier(&mut self) -> Result<String, String> {
        match self.current_token.clone() {
            Some(Token::Identifier(identifier)) => {
                self.advance();
                Ok(identifier)
            }
            Some(token) => Err(format!(
                "Expected identifier but received token {:?}",
                token
            )),
            None => Err(format!("Expected identifier but got no token")),
        }
    }

    /// Expect a specific token but do not consume it.
    fn check(&self, expected: Token) -> bool {
        if let Some(token) = self.next_token.as_ref() {
            return token == &expected;
        }
        false
    }

    /// Look up the next token in the sequence
    fn peek(&self) -> Option<Token> {
        self.next_token.clone()
    }

    pub fn parse_program(&mut self) -> Result<ASTNode, String> {
        let mut functions = Vec::new();

        while self.next_token.is_some() {
            let function = self.parse_function_declaration()?;
            functions.push(function);
        }
        
        Ok(ASTNode::Program(functions))
    }

    /// Parse a function declaration from the Tokens generated by the lexer
    /// and return the AST node representing the function.
    fn parse_function_declaration(&mut self) -> Result<ASTNode, String> {
        let mut argument_identifiers = Vec::new();
        let mut statements = Vec::new();
        let identifier;

        self.expect(Token::Func)?;
        identifier = self.expect_identifier()?;
        self.expect(Token::OpenParen)?;
        self.expect(Token::CloseParen)?;
        self.expect(Token::OpenBrace)?;
        self.expect(Token::CloseBrace)?;

        Ok(ASTNode::FunctionDeclaration(
            identifier,
            argument_identifiers,
            statements,
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Test the most basic program declaration possible.
    #[test]
    fn test_parser() {
        let program = "
            func foo() {
            }";
        let lexer = Lexer::new(program);

        let mut parser = super::Parser::new(lexer);
        let ast = parser.parse_program();
        assert!(ast.is_ok());

        let ast = ast.unwrap();
        match ast {
            ASTNode::Program(functions) => {
                assert_eq!(functions.len(), 1);
                let function = functions.first().unwrap();
                match function {
                    ASTNode::FunctionDeclaration(name, arguments, statements) => {
                        assert_eq!(name, "foo");
                        assert_eq!(arguments.len(), 0);
                        assert_eq!(statements.len(), 0);
                    }
                    _ => panic!("Expected function declaration"),
                }
            }
            _ => panic!("Expected program"),
        }
    }
}
