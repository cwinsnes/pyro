use crate::lexer::{Lexer, Token, TokenType};
use crate::error::CompilerError;
use crate::error::CompilerErrorType::ASTError;

#[derive(Debug, Clone, PartialEq)]
pub(crate) enum VariableType {
    Void,
    Integer,
    Boolean,
    Float,
    String,
    Class(String),
}

#[derive(Debug, Clone, PartialEq)]
pub(crate) struct Argument {
    pub variable_type: VariableType,
    pub identifier: String,
}

#[derive(Debug, Clone, PartialEq)]
pub(crate) enum Operator {
    Plus,
    Minus,
    Multiplication,
    Division,

    LessThan,
    GreaterThan,
    EqualTo,
}

fn token_to_operator(token: &Token) -> Result<Operator, CompilerError> {
    match token.token_type {
        TokenType::Plus => Ok(Operator::Plus),
        TokenType::Minus => Ok(Operator::Minus),
        TokenType::Asterisk => Ok(Operator::Multiplication),
        TokenType::Slash => Ok(Operator::Division),

        TokenType::LessThan => Ok(Operator::LessThan),
        TokenType::GreaterThan => Ok(Operator::GreaterThan),
        TokenType::EqualTo => Ok(Operator::EqualTo),

        _ => Err(CompilerError::new(
            ASTError,
            token.line_number,
            format!("Invalid operator: {:?}", token),
        )),
    }
}

// TODO: Probably want to create more Structs to represent the
//       tokens. To avoid having to parse mentally what the Box-values
//       and Vecs point to.
#[derive(Debug, Clone, PartialEq)]
pub(crate) enum ASTNode {
    Program(Vec<ASTNode>),

    FunctionDeclaration {
        identifier: String,
        arguments: Vec<Argument>,
        return_type: VariableType,
        body: Vec<ASTNode>,
    },
    FunctionCall(String, Vec<ASTNode>),

    IfStatement {
        condition: Box<ASTNode>,
        then_body: Vec<ASTNode>,
        else_body: Vec<ASTNode>,
    },

    WhileStatement {
        condition: Box<ASTNode>,
        body: Vec<ASTNode>,
    },

    ForStatement {
        iterator_identifier: String,
        range: (Box<ASTNode>, Box<ASTNode>),
        body: Vec<ASTNode>,
    },

    ClassDeclaration {
        identifier: String,
        fields: Vec<Argument>,
        methods: Vec<ASTNode>,
    },

    ObjectAllocation(VariableType),
    ObjectFieldAccess {
        object_identifier: String,
        field_identifier: String,
    },
    ObjectFieldAssignment {
        object_identifier: String,
        field_identifier: String,
        value: Box<ASTNode>,
    },

    ArrayAllocation {
        variable_type: VariableType,
        size: Box<ASTNode>,
    },
    ArrayAccess(String, Box<ASTNode>),
    ArrayAssignment(String, Box<ASTNode>, Box<ASTNode>),

    DestroyVariable(String),
    VariableAssignment(String, Box<ASTNode>),
    LetDeclaration(String, Box<ASTNode>),
    ReturnStatement(Box<ASTNode>),

    BinaryOp {
        operator: Operator,
        left: Box<ASTNode>,
        right: Box<ASTNode>,
    },
    Identifier(String),
    IntegerLiteral(i64),
    FloatLiteral(f64),
    StringLiteral(String),
    BooleanLiteral(bool),
}

/// Parser for the simple Pyro programming language.
///
/// The `Parser` struct provides a basic recursive descent parser
/// that can parse a stream of tokens generated by the `Lexer` into
/// an abstract syntax tree (AST) representing the program.
pub(crate) struct Parser<'a> {
    lexer: Lexer<'a>,
    current_token: Token,
    next_token: Token,
}

impl<'a> Parser<'a> {
    pub(crate) fn new(lexer: Lexer<'a>) -> Parser<'a> {
        let mut parser = Parser {
            lexer,
            current_token: Token::new(TokenType::NoToken, 0),
            next_token: Token::new(TokenType::NoToken, 0),
        };

        let init_parser = |parser: &mut Parser| -> Result<(), CompilerError> {
            parser.advance()?;
            parser.advance()?;
            Ok(())
        };

        if let Err(_err) = init_parser(&mut parser) {
            panic!("Error while initializing parser");
        }

        parser
    }

    /// Parses an entire Program from the input lexer.
    ///
    /// Returns a `CompilerError` if the input is an invalid pyro program.
    pub(crate) fn parse_program(&mut self) -> Result<ASTNode, CompilerError> {
        let mut program_contents = Vec::new();

        while self.peek_ahead().token_type != TokenType::Eof {
            match self.peek_current().token_type {
                TokenType::Class => {
                    let class = self.parse_class_declaration()?;
                    program_contents.push(class);
                }
                TokenType::Func => {
                    let function = self.parse_function_declaration()?;
                    program_contents.push(function);
                }
                _ => {
                    return Err(CompilerError::new(
                        ASTError,
                        self.current_token.line_number,
                        format!("Unexpected token: {:?}", self.current_token.token_type),
                    ))
                }
            }
        }

        Ok(ASTNode::Program(program_contents))
    }

    /// Advance the internal lexer one step.
    fn advance(&mut self) -> Result<(), CompilerError> {
        self.current_token = self.next_token.clone();
        self.next_token = self.lexer.next_token()?;
        Ok(())
    }

    /// Expect a specific token and consume it.
    fn expect(&mut self, expected: TokenType) -> Result<(), CompilerError> {
        match self.peek_current() {
            token if token == expected => self.advance(),
            token => Err(CompilerError::new(
                ASTError,
                token.line_number,
                format!(
                    "Expected token {:?} but received {:?}",
                    expected, token.token_type
                ),
            )),
        }
    }

    /// Expect an identifier Token, consume it, and return the identifier
    fn expect_identifier(&mut self) -> Result<String, CompilerError> {
        match self.peek_current().token_type {
            TokenType::Identifier(identifier) => {
                self.advance()?;
                Ok(identifier)
            }
            TokenType::SelfIdentifier => {
                self.advance()?;
                Ok("self".into())
            }
            token_type => Err(CompilerError::new(
                ASTError,
                self.current_token.line_number,
                format!("Expected identifier but received token {:?}", token_type),
            )),
        }
    }

    /// Expect one of the possible non-void Pyro types, consume it, and return
    /// the type.
    ///
    /// Returns the VariableType-representation of the encountered type.
    /// Returns an `Err` if any other kind of token was encountered.
    fn expect_variable_type(&mut self) -> Result<VariableType, CompilerError> {
        match self.peek_current().token_type {
            TokenType::Integer => {
                self.advance()?;
                Ok(VariableType::Integer)
            }
            TokenType::Float => {
                self.advance()?;
                Ok(VariableType::Float)
            }
            TokenType::Boolean => {
                self.advance()?;
                Ok(VariableType::Boolean)
            }
            TokenType::String => {
                self.advance()?;
                Ok(VariableType::String)
            }
            TokenType::Identifier(identifier) => {
                self.advance()?;
                Ok(VariableType::Class(identifier))
            }
            token_type => Err(CompilerError::new(
                ASTError,
                self.current_token.line_number,
                format!(
                    "Expected variable type token but received token {:?}",
                    token_type
                ),
            )),
        }
    }

    /// Expect a Pyro type followed by an identifier, consume them, and
    /// return the resulting `Argument`.
    ///
    /// Returns `Err` if an `Argument` could not be constructed.
    fn expect_variable(&mut self) -> Result<Argument, CompilerError> {
        let argument_type = self.expect_variable_type()?;
        let identifier = self.expect_identifier()?;

        Ok(Argument {
            variable_type: argument_type,
            identifier,
        })
    }

    /// Assert that a specific token type is the current token in the sequence
    /// but do not consume it.
    fn check(&self, expected: TokenType) -> bool {
        self.current_token == expected
    }

    /// Peek at the current token in the sequence without consuming it.
    fn peek_current(&self) -> Token {
        self.current_token.clone()
    }

    /// Look up the next token in the sequence but do not consume it.
    fn peek_ahead(&self) -> Token {
        self.next_token.clone()
    }

    fn parse_class_declaration(&mut self) -> Result<ASTNode, CompilerError> {
        self.expect(TokenType::Class)?;
        let identifier = self.expect_identifier()?;
        self.expect(TokenType::OpenBrace)?;

        let fields = self.parse_class_variables()?;
        let mut methods = Vec::new();

        while self.peek_current() == TokenType::Func {
            let method = self.parse_function_declaration()?;
            methods.push(method);
        }

        self.expect(TokenType::CloseBrace)?;

        return Ok(ASTNode::ClassDeclaration {
            identifier,
            fields,
            methods,
        });
    }

    fn parse_class_variables(&mut self) -> Result<Vec<Argument>, CompilerError> {
        let mut variables = Vec::new();

        if self.check(TokenType::CloseBrace) || self.check(TokenType::Func) {
            return Ok(variables);
        }

        loop {
            let variable = self.expect_variable()?;
            variables.push(variable);
            self.expect(TokenType::SemiColon)?;

            match self.peek_current().token_type {
                TokenType::Func | TokenType::CloseBrace => {
                    return Ok(variables);
                }
                _ => continue,
            }
        }
    }

    fn parse_object_access(&mut self) -> Result<ASTNode, CompilerError> {
        let object_identifier = self.expect_identifier()?;
        self.expect(TokenType::Dot)?;
        let field_identifier = self.expect_identifier()?;

        if self.peek_current() == TokenType::EqualSign {
            self.expect(TokenType::EqualSign)?;
            return Ok(ASTNode::ObjectFieldAssignment {
                object_identifier,
                field_identifier,
                value: Box::new(self.parse_expression()?),
            });
        }
        
        else if self.peek_current() == TokenType::OpenParen {
            println!("Method");
        }

        Ok(ASTNode::ObjectFieldAccess {
            object_identifier,
            field_identifier,
        })
    }

    /// Parse a function declaration from the Tokens generated by the lexer.
    ///
    /// Return `Err` if a valid function couldn't be parsed.
    fn parse_function_declaration(&mut self) -> Result<ASTNode, CompilerError> {
        self.expect(TokenType::Func)?;
        let identifier = self.expect_identifier()?;
        let argument_list = self.parse_argument_list()?;
        let variable_type = self.parse_return_type()?;
        let statements = self.parse_statement_list()?;

        Ok(ASTNode::FunctionDeclaration {
            identifier,
            arguments: argument_list,
            return_type: variable_type,
            body: statements,
        })
    }

    /// Parse function argument list enclosed by parenthesis.
    fn parse_argument_list(&mut self) -> Result<Vec<Argument>, CompilerError> {
        let mut arguments = Vec::new();

        self.expect(TokenType::OpenParen)?;
        if self.check(TokenType::CloseParen) {
            self.advance()?;
            return Ok(arguments);
        }

        loop {
            let argument = self.expect_variable()?;
            arguments.push(argument);
            match self.peek_current().token_type {
                TokenType::Comma => {
                    self.advance()?;
                    continue;
                }
                TokenType::CloseParen => {
                    self.advance()?;
                    return Ok(arguments);
                }
                other => {
                    return Err(CompilerError::new(
                        ASTError,
                        self.peek_current().line_number,
                        format!(
                            "Expected comma (',') or closing paren (')') but got {:?}",
                            other
                        ),
                    ));
                }
            }
        }
    }

    // Parse the (optional) return type of the currently parsed function, indicating
    // which VariableType will be returned by the function.
    fn parse_return_type(&mut self) -> Result<VariableType, CompilerError> {
        match self.peek_current().token_type {
            TokenType::GreaterThan => {
                self.advance()?;
                self.expect_variable_type()
            }
            _ => Ok(VariableType::Void),
        }
    }

    /// Parse a statement list enclosed by braces.
    fn parse_statement_list(&mut self) -> Result<Vec<ASTNode>, CompilerError> {
        let mut statements = Vec::new();

        self.expect(TokenType::OpenBrace)?;
        if self.check(TokenType::CloseBrace) {
            self.advance()?;
            return Ok(statements);
        }

        loop {
            let statement = self.parse_statement()?;
            statements.push(statement);
            match self.peek_current().token_type {
                TokenType::CloseBrace => {
                    self.advance()?;
                    return Ok(statements);
                }
                TokenType::Eof => {
                    return Err(CompilerError::new(
                        ASTError,
                        self.peek_current().line_number,
                        "Reached EOF while scanning for closing brace ('}}')".to_string(),
                    ));
                }
                _other => continue,
            }
        }
    }

    /// Parse a return statement capable of returning any expression.
    fn parse_return_statement(&mut self) -> Result<ASTNode, CompilerError> {
        self.expect(TokenType::Return)?;
        let expression = self.parse_expression()?;
        self.expect(TokenType::SemiColon)?;

        Ok(ASTNode::ReturnStatement(Box::new(expression)))
    }

    /// Parse an if statement with an optional else branch.
    ///
    /// Returns `Err` if the If statement could not be parsed.
    fn parse_if_statement(&mut self) -> Result<ASTNode, CompilerError> {
        self.expect(TokenType::If)?;
        self.expect(TokenType::OpenParen)?;

        let condition = self.parse_expression()?;

        self.expect(TokenType::CloseParen)?;
        let true_statements = self.parse_statement_list()?;

        let else_statements;
        if self.peek_current() == TokenType::Else {
            self.expect(TokenType::Else)?;
            else_statements = self.parse_statement_list()?;
        } else {
            else_statements = Vec::new();
        }

        Ok(ASTNode::IfStatement {
            condition: Box::new(condition),
            then_body: true_statements,
            else_body: else_statements,
        })
    }

    fn parse_for_loop(&mut self) -> Result<ASTNode, CompilerError> {
        self.expect(TokenType::For)?;
        self.expect(TokenType::OpenParen)?;

        let identifier = self.expect_identifier()?;

        self.expect(TokenType::From)?;
        let range_left = self.parse_expression()?;

        self.expect(TokenType::To)?;
        let range_right = self.parse_expression()?;

        self.expect(TokenType::CloseParen)?;
        let statements = self.parse_statement_list()?;

        Ok(ASTNode::ForStatement {
            iterator_identifier: identifier,
            range: (Box::new(range_left), Box::new(range_right)),
            body: statements,
        })
    }

    fn parse_while_loop(&mut self) -> Result<ASTNode, CompilerError> {
        self.expect(TokenType::While)?;
        self.expect(TokenType::OpenParen)?;

        let condition = self.parse_expression()?;

        self.expect(TokenType::CloseParen)?;
        let statements = self.parse_statement_list()?;

        Ok(ASTNode::WhileStatement {
            condition: Box::new(condition),
            body: statements,
        })
    }

    /// Parse any kind of pyro statement.
    ///
    /// Returns Err if any of the statements was unable to be parsed or if the
    /// end of file was reached while parsing.
    fn parse_statement(&mut self) -> Result<ASTNode, CompilerError> {
        let return_node;
        match self.peek_current().token_type {
            TokenType::Let => {
                return_node = self.parse_let_statement()?;
            }
            TokenType::Return => {
                return_node = self.parse_return_statement()?;
            }
            TokenType::Destroy => {
                return_node = self.parse_destroy_statement()?;
            }
            TokenType::If => {
                return_node = self.parse_if_statement()?;
            }
            TokenType::For => {
                return_node = self.parse_for_loop()?;
            }
            TokenType::While => {
                return_node = self.parse_while_loop()?;
            }
            TokenType::Eof => {
                return Err(CompilerError::new(
                    ASTError,
                    self.peek_current().line_number,
                    "Reached EOF while parsing statements".to_string(),
                ));
            }
            _ => {
                return_node = self.parse_expression()?;
                self.expect(TokenType::SemiColon)?;
            }
        }
        Ok(return_node)
    }

    fn parse_let_statement(&mut self) -> Result<ASTNode, CompilerError> {
        let identifier;
        let expression;

        self.expect(TokenType::Let)?;
        identifier = self.expect_identifier()?;
        self.expect(TokenType::EqualSign)?;
        if self.peek_current().token_type == TokenType::Create {
            expression = self.parse_create()?;
        } else {
            expression = self.parse_expression()?;
        }
        self.expect(TokenType::SemiColon)?;

        Ok(ASTNode::LetDeclaration(identifier, Box::new(expression)))
    }

    fn parse_array_access(&mut self) -> Result<ASTNode, CompilerError> {
        let identifier = self.expect_identifier()?;
        self.expect(TokenType::OpenBracket)?;
        let index = self.parse_expression()?;
        self.expect(TokenType::CloseBracket)?;

        if self.peek_current() == TokenType::EqualSign {
            self.expect(TokenType::EqualSign)?;
            let value = self.parse_expression()?;

            return Ok(ASTNode::ArrayAssignment(
                identifier,
                Box::new(index),
                Box::new(value),
            ));
        }

        Ok(ASTNode::ArrayAccess(identifier, Box::new(index)))
    }

    fn parse_variable_assignment(&mut self) -> Result<ASTNode, CompilerError> {
        let identifier = self.expect_identifier()?;
        self.expect(TokenType::EqualSign)?;
        let value = self.parse_expression()?;
        Ok(ASTNode::VariableAssignment(identifier, Box::new(value)))
    }

    /// Parse a full call to a function, with function name and arguments.
    fn parse_function_call(&mut self) -> Result<ASTNode, CompilerError> {
        // TODO: This is VERY similar to parse_argument_list
        // TODO: Would make sense to join the two somehow.
        let mut argument_list = Vec::new();

        let identifier = self.expect_identifier()?;
        self.expect(TokenType::OpenParen)?;
        if self.check(TokenType::CloseParen) {
            self.advance()?;
            return Ok(ASTNode::FunctionCall(identifier, argument_list));
        }
        loop {
            let argument = self.parse_expression()?;
            argument_list.push(argument);
            match self.peek_current().token_type {
                TokenType::Comma => {
                    self.advance()?;
                    continue;
                }
                TokenType::CloseParen => {
                    self.advance()?;
                    return Ok(ASTNode::FunctionCall(identifier, argument_list));
                }
                other => {
                    return Err(CompilerError::new(
                        ASTError,
                        self.peek_current().line_number,
                        format!(
                            "Expected comma (',') or closing paren (')') but got {:?}",
                            other
                        ),
                    ));
                }
            }
        }
    }

    fn parse_create(&mut self) -> Result<ASTNode, CompilerError> {
        self.expect(TokenType::Create)?;
        let variable_type = self.expect_variable_type()?;

        if self.peek_ahead() == TokenType::OpenBracket {
            self.expect(TokenType::OpenBracket)?;
            let size = self.parse_expression()?;
            self.expect(TokenType::CloseBracket)?;

            return Ok(ASTNode::ArrayAllocation {
                variable_type,
                size: Box::new(size),
            });
        }

        Ok(ASTNode::ObjectAllocation(variable_type))
    }

    fn parse_destroy_statement(&mut self) -> Result<ASTNode, CompilerError> {
        self.expect(TokenType::Destroy)?;
        let variable_name = self.expect_identifier()?;
        self.expect(TokenType::SemiColon)?;
        Ok(ASTNode::DestroyVariable(variable_name))
    }

    fn parse_identifier(&mut self) -> Result<ASTNode, CompilerError> {
        let return_node: ASTNode;
        if self.peek_ahead() == TokenType::OpenParen {
            return_node = self.parse_function_call()?;
        } else if self.peek_ahead() == TokenType::OpenBracket {
            return_node = self.parse_array_access()?;
        } else if self.peek_ahead() == TokenType::EqualSign {
            return_node = self.parse_variable_assignment()?;
        } else if self.peek_ahead() == TokenType::Dot {
            return_node = self.parse_object_access()?
        } else {
            let identifier = self.expect_identifier()?;
            return_node = ASTNode::Identifier(identifier);
        }
        Ok(return_node)
    }

    /// Parse an expression from the input tokens.
    fn parse_expression(&mut self) -> Result<ASTNode, CompilerError> {
        let mut left;
        match self.peek_current().token_type {
            TokenType::IntegerLiteral(literal) => {
                self.advance()?;
                left = ASTNode::IntegerLiteral(literal);
            }
            TokenType::FloatLiteral(literal) => {
                self.advance()?;
                left = ASTNode::FloatLiteral(literal);
            }
            TokenType::BooleanLiteral(literal) => {
                self.advance()?;
                left = ASTNode::BooleanLiteral(literal);
            }
            TokenType::StringLiteral(string) => {
                self.advance()?;
                left = ASTNode::StringLiteral(string);
            }
            TokenType::Identifier(_) | TokenType::SelfIdentifier => {
                left = self.parse_identifier()?;
            }
            other => {
                return Err(CompilerError::new(
                    ASTError,
                    self.peek_current().line_number,
                    format!("Expected expression but got {:?}", other),
                ))
            }
        }
        if self.check(TokenType::Plus)
            || self.check(TokenType::Minus)
            || self.check(TokenType::Asterisk)
            || self.check(TokenType::Slash)
            || self.check(TokenType::LessThan)
            || self.check(TokenType::GreaterThan)
            || self.check(TokenType::EqualTo)
        {
            let operator = token_to_operator(&self.peek_current())?;
            self.advance()?;
            let right = self.parse_expression()?;
            left = ASTNode::BinaryOp {
                operator,
                left: Box::new(left),
                right: Box::new(right),
            };
        }

        Ok(left)
    }
}
