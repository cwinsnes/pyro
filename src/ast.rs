use crate::lexer::Lexer;
use crate::lexer::Token;

#[derive(Debug, Clone, PartialEq)]
pub enum VariableType {
    Number,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Argument {
    pub argument_type: VariableType,
    pub identifier: String,
}

// #[derive(Debug, PartialEq)]
// pub enum Operator {
//     Plus,
// }

#[derive(Debug, Clone, PartialEq)]
pub enum ASTNode {
    Program(Vec<ASTNode>),

    FunctionDeclaration(String, Vec<Argument>, Vec<ASTNode>),
    FunctionCall(String, Vec<ASTNode>),

    LetDeclaration(String, Box<ASTNode>),

    // Print(Box<ASTNode>),
    // BinaryOp(Box<ASTNode>, Operator, Box<ASTNode>),
    Identifier(String),
    IntegerLiteral(i64),
}

/// Parser for the simple Pyro programming language.
///
/// The `Parser` struct provides a basic recursive descent parser
/// that can parse a stream of tokens generated by the `Lexer` into
/// an abstract syntax tree (AST) representing the program.
pub struct Parser<'a> {
    lexer: Lexer<'a>,
    current_token: Option<Token>,
    next_token: Option<Token>,
}

impl<'a> Parser<'a> {
    pub fn new(lexer: Lexer<'a>) -> Parser<'a> {
        let mut parser = Parser {
            lexer,
            current_token: None,
            next_token: None,
        };

        let init_parser = |parser: &mut Parser| -> Result<(), String> {
            parser.advance()?;
            parser.advance()?;
            Ok(())
        };

        if let Err(_err) = init_parser(&mut parser) {
            panic!("Error while initializing parser");
        }

        parser
    }

    /// Advance the internal lexer.
    fn advance(&mut self) -> Result<(), String> {
        self.current_token = self.next_token.take();
        self.next_token = self.lexer.next_token()?;
        Ok(())
    }

    /// Expect a specific token and consume it.
    fn expect(&mut self, expected: Token) -> Result<(), String> {
        match self.current_token.clone() {
            Some(token) if token == expected => self.advance(),
            Some(token) => Err(format!(
                "Expected token {:?} but received {:?}",
                expected, token
            )),
            None => Err(format!("Expected token {:?} but got no token", expected)),
        }
    }

    /// Expect an identifier Token, consume it, and return the identifier
    fn expect_identifier(&mut self) -> Result<String, String> {
        match self.current_token.clone() {
            Some(Token::Identifier(identifier)) => {
                self.advance()?;
                Ok(identifier)
            }
            Some(token) => Err(format!(
                "Expected identifier but received token {:?}",
                token
            )),
            None => Err(format!("Expected identifier but got no token")),
        }
    }

    // fn expect_number(&mut self) -> Result<i32, String> {
    //     match self.current_token.clone() {
    //         Some(Token::NumberLiteral(number)) => {
    //             self.advance()?;
    //             Ok(number)
    //         }
    //         Some(token) => Err(format!("Expected number but received token {:?}", token)),
    //         None => Err(format!("Expected number but got no token")),
    //     }
    // }

    /// Expect one of the possible Pyro types, consume it, and return the type.
    fn expect_variable_type(&mut self) -> Result<VariableType, String> {
        match self.current_token.clone() {
            Some(Token::Number) => {
                self.advance()?;
                Ok(VariableType::Number)
            }
            Some(token) => Err(format!("Expected type type but received token {:?}", token)),
            None => Err(format!("Expected variable type but got no token")),
        }
    }

    /// Expect a Pyro type followed by an identifier, consume them, and
    /// return the resulting Argument.
    fn expect_argument(&mut self) -> Result<Argument, String> {
        let argument_type = self.expect_variable_type()?;
        let identifier = self.expect_identifier()?;

        Ok(Argument {
            argument_type,
            identifier,
        })
    }

    /// Expect a specific token but do not consume it.
    fn check(&self, expected: Token) -> bool {
        if let Some(token) = self.current_token.as_ref() {
            return token == &expected;
        }
        false
    }

    /// Peek at the current token in the sequence.
    fn peek_current(&self) -> Option<Token> {
        self.current_token.clone()
    }

    /// Look up the next token in the sequence
    fn peek_ahead(&self) -> Option<Token> {
        self.next_token.clone()
    }

    pub fn parse_program(&mut self) -> Result<ASTNode, String> {
        let mut functions = Vec::new();

        while self.next_token.is_some() {
            let function = self.parse_function_declaration()?;
            functions.push(function);
        }

        Ok(ASTNode::Program(functions))
    }

    /// Parse a function declaration from the Tokens generated by the lexer
    /// and return the AST node representing the function.
    fn parse_function_declaration(&mut self) -> Result<ASTNode, String> {
        self.expect(Token::Func)?;
        let identifier = self.expect_identifier()?;
        let argument_list = self.parse_argument_list()?;
        let statements = self.parse_statement_list()?;

        Ok(ASTNode::FunctionDeclaration(
            identifier,
            argument_list,
            statements,
        ))
    }

    /// Parse argument list enclosed by parenthesis.
    fn parse_argument_list(&mut self) -> Result<Vec<Argument>, String> {
        let mut arguments = Vec::new();

        self.expect(Token::OpenParen)?;
        if self.check(Token::CloseParen) {
            self.advance()?;
            return Ok(arguments);
        }

        loop {
            let argument = self.expect_argument()?;
            arguments.push(argument);
            match self.peek_current() {
                Some(Token::Comma) => {
                    self.advance()?;
                    continue;
                }
                Some(Token::CloseParen) => {
                    self.advance()?;
                    return Ok(arguments);
                }
                other => {
                    return Err(format!(
                        "Expected comma (',') or closing paren (')') but got {:?}",
                        other
                    ));
                }
            }
        }
    }

    /// Parse a statement list enclosed by braces.
    fn parse_statement_list(&mut self) -> Result<Vec<ASTNode>, String> {
        let mut statements = Vec::new();

        self.expect(Token::OpenBrace)?;
        if self.check(Token::CloseBrace) {
            self.advance()?;
            return Ok(statements);
        }

        loop {
            let statement = self.parse_statement()?;
            statements.push(statement);
            println!("{:?}", self.peek_current());
            match self.peek_current() {
                Some(Token::CloseBrace) => {
                    self.advance()?;
                    return Ok(statements);
                }
                Some(Token::Eof) | None => {
                    return Err("Reached EOF while scanning for closing brace ('}}')".to_string());
                }
                _other => continue,
            }
        }
    }

    fn parse_statement(&mut self) -> Result<ASTNode, String> {
        let return_node;
        match self.peek_current() {
            Some(Token::Let) => {
                return_node = self.parse_let_declaration()?;
            }
            Some(Token::Eof) | None => {
                return Err("Reached EOF while parsing statements".to_string());
            }
            Some(_) => {
                return_node = self.parse_expression()?;
            }
        }
        self.expect(Token::SemiColon)?;
        Ok(return_node)
    }

    fn parse_let_declaration(&mut self) -> Result<ASTNode, String> {
        let identifier;
        let expression;

        self.expect(Token::Let)?;
        identifier = self.expect_identifier()?;
        self.expect(Token::Assignment)?;
        expression = self.parse_expression()?;

        Ok(ASTNode::LetDeclaration(identifier, Box::new(expression)))
    }

    /// Parse a full call to a function, with function name and arguments.
    fn parse_function_call(&mut self) -> Result<ASTNode, String> {
        // TODO: This is VERY similar to parse_argument_list
        // TODO: Would make sense to join the two somehow.
        let mut argument_list = Vec::new();

        let identifier = self.expect_identifier()?;
        self.expect(Token::OpenParen)?;
        if self.check(Token::CloseParen) {
            self.advance()?;
            return Ok(ASTNode::FunctionCall(identifier, argument_list));
        }
        loop {
            let argument = self.parse_expression()?;
            argument_list.push(argument);
            match self.peek_current() {
                Some(Token::Comma) => {
                    self.advance()?;
                    continue;
                }
                Some(Token::CloseParen) => {
                    self.advance()?;
                    return Ok(ASTNode::FunctionCall(identifier, argument_list));
                }
                other => {
                    return Err(format!(
                        "Expected comma (',') or closing paren (')') but got {:?}",
                        other
                    ));
                }
            }
        }
    }

    /// Parse an expression from the input tokens.
    /// Currently only supports integer literals and function calls
    /// as expressions.
    fn parse_expression(&mut self) -> Result<ASTNode, String> {
        match self.peek_current() {
            Some(Token::NumberLiteral(literal)) => {
                self.advance()?;
                Ok(ASTNode::IntegerLiteral(literal))
            }
            Some(Token::Identifier(literal)) => {
                if self.peek_ahead() == Some(Token::OpenParen) {
                    return self.parse_function_call();
                }
                self.advance()?;
                return Ok(ASTNode::Identifier(literal));
            }
            other => Err(format!("Expected expression but got {:?}", other)),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_function() {
        let program = "
            func foo() {
            }";
        let lexer = Lexer::new(program);

        let mut parser = super::Parser::new(lexer);
        let ast = parser.parse_program();
        if ast.is_err() {
            panic!("{:?}", ast);
        }

        let ast = ast.unwrap();
        match ast {
            ASTNode::Program(functions) => {
                assert_eq!(functions.len(), 1);
                let function = functions.first().unwrap();
                match function {
                    ASTNode::FunctionDeclaration(name, arguments, statements) => {
                        assert_eq!(name, "foo");
                        assert_eq!(arguments.len(), 0);
                        assert_eq!(statements.len(), 0);
                    }
                    _ => panic!("Expected function declaration"),
                }
            }
            _ => panic!("Expected program"),
        }
    }

    #[test]
    fn test_function_with_arguments() {
        let program = "
            func foo(number x, number y, number z) {
            }";
        let lexer = Lexer::new(program);

        let mut parser = super::Parser::new(lexer);
        let ast = parser.parse_program();
        if ast.is_err() {
            panic!("{:?}", ast);
        }

        let ast = ast.unwrap();
        match ast {
            ASTNode::Program(functions) => {
                assert_eq!(functions.len(), 1);
                let function = functions.first().unwrap();
                match function {
                    ASTNode::FunctionDeclaration(name, arguments, statements) => {
                        assert_eq!(name, "foo");
                        assert_eq!(arguments.len(), 3);
                        assert_eq!(
                            arguments,
                            &vec!(
                                Argument {
                                    argument_type: VariableType::Number,
                                    identifier: "x".to_string(),
                                },
                                Argument {
                                    argument_type: VariableType::Number,
                                    identifier: "y".to_string(),
                                },
                                Argument {
                                    argument_type: VariableType::Number,
                                    identifier: "z".to_string(),
                                },
                            )
                        );
                        assert_eq!(statements.len(), 0);
                    }
                    _ => panic!("Expected function declaration"),
                }
            }
            _ => panic!("Expected program"),
        }
    }

    #[test]
    fn test_function_with_let_statements() {
        let program = "
            func foo() {
                let x = 1;
                let y = x;
            }";
        let lexer = Lexer::new(program);

        let mut parser = super::Parser::new(lexer);
        let ast = parser.parse_program();
        if ast.is_err() {
            panic!("{:?}", ast);
        }

        let ast = ast.unwrap();
        match ast {
            ASTNode::Program(functions) => {
                assert_eq!(functions.len(), 1);
                let function = functions.first().unwrap();
                match function {
                    ASTNode::FunctionDeclaration(name, arguments, statements) => {
                        assert_eq!(name, "foo");
                        assert_eq!(arguments.len(), 0);
                        assert_eq!(statements.len(), 2);

                        match statements.get(0).unwrap() {
                            ASTNode::LetDeclaration(identifier, expression) => {
                                assert_eq!(identifier, "x");
                                assert_eq!(**expression, ASTNode::IntegerLiteral(1));
                            }
                            _ => panic!("Expected let declaration"),
                        }

                        match statements.get(1).unwrap() {
                            ASTNode::LetDeclaration(identifier, expression) => {
                                assert_eq!(identifier, "y");
                                assert_eq!(**expression, ASTNode::Identifier("x".to_string()));
                            }
                            _ => panic!("Expected let declaration"),
                        }
                    }
                    _ => panic!("Expected function declaration"),
                }
            }
            _ => panic!("Expected program"),
        }
    }

    #[test]
    fn test_function_with_print_statement() {
        let program = "
            func foo() {
                print (x);
            }";
        let lexer = Lexer::new(program);

        let mut parser = super::Parser::new(lexer);
        let ast = parser.parse_program();
        if ast.is_err() {
            panic!("{:?}", ast);
        }

        let ast = ast.unwrap();
        match ast {
            ASTNode::Program(functions) => {
                assert_eq!(functions.len(), 1);
                let function = functions.first().unwrap();
                match function {
                    ASTNode::FunctionDeclaration(name, arguments, statements) => {
                        assert_eq!(name, "foo");
                        assert_eq!(arguments.len(), 0);
                        assert_eq!(statements.len(), 1);

                        match statements.get(0).unwrap() {
                            ASTNode::FunctionCall(function_name, arguments) => {
                                assert_eq!(function_name, "print");
                                assert_eq!(arguments.len(), 1);
                                assert_eq!(
                                    *arguments.first().unwrap(),
                                    ASTNode::Identifier("x".to_string())
                                );
                            }
                            _ => panic!("Expected print statement"),
                        }
                    }
                    _ => panic!("Expected function declaration"),
                }
            }
            _ => panic!("Expected program"),
        }
    }

    #[test]
    fn test_error_let_instead_of_expression() {
        let program = "
            func foo() {
                let x = let y;
            }";
        let lexer = Lexer::new(program);

        let mut parser = super::Parser::new(lexer);
        let ast = parser.parse_program();
        assert!(ast.is_err());
    }
}
